# 加载

## 1.减少页面加载的方法

1.优化图片

2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）

3.优化 CSS（压缩合并 css，如 margin-top,margin-left...)

4.网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。）

5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。 当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）

6.减少 http 请求（合并文件，合并图片）

## 2.web 的首屏加载

[https://zhuanlan.zhihu.com/p/88639980?utm_source=wechat_session]

### 白屏加载和首屏加载时间的区别

白屏时间是指浏览器从响应用户输入网址地址，到浏览器开始显示内容的时间。

首屏时间是指浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但在当前视窗的内容需要。

白屏时间是首屏时间的一个子集。

### 如何优化首屏加载时间

1. cdn 分发（减少传输距离）。
   通过在多台服务器部署相同的副本，当用户访问时，服务器根据用户跟哪台服务器距离近，来决定哪台服务器去响应这个请求。

2. 后端在业务层的缓存。
   数据库查询缓存是可以设置缓存的，这个对于处于高频率的请求很有用。浏览器一般不会对 content-type: application/json；的接口进行缓存，所以有时需要我们手动地为接口设置缓存。比如一个用户的签到状态，它的缓存时间可以设置到明天之前。

3. 静态文件缓存方案。
   这个最常看到。现在流行的方式是文件 hash+强缓存的一个方案。比如 hash+ cache control: max-age=1 年。

4. 前端的资源动态加载：
   a. 路由动态加载，最常用的做法，以页面为单位，进行动态加载。
   b. 组件动态加载(offScreen Component)，对于不在当前视窗的组件，先不加载。
   c. 图片懒加载(offScreen Image)，同上。值得庆幸的是，越来越多的浏览器支持原生的懒
   加载，通过给 img 标签加上 loading="lazy 来开启懒加载模式。

5. 合并请求。
   这点在 http1.1 比较明显，因为 http1.1 的请求是串行的（尽管有多个 tcp 通道），每个请求都需要往返后才能继续下个请求。此时合并请求可以减少在路途上浪费的时间，此外还会带来重复的请求头部信息（比如 cookie)。在 http2.0 中这个问题会弱化很多，但也有做的必要。

6. 页面使用骨架屏。
   意思是在首屏加载完成之前，通过渲染一些简单元素进行占位。骨架屏的好处在于可以减少用户等待时的急躁情绪。这点很有效，在很多成熟的网站都有大量应用。没有骨架屏的话，一个 loading 图也是可以的。

7. 使用 ssr 渲染。

8. 引入 http2.0。
   http2.0 对比 http1.1，最主要的提升是传输性能，在接口小而多的时候会更加明显。

9. 利用好 http 压缩。
   即使是最普通的 gzip，也能把 bootstrap.min.css 压缩到原来的 17%。可见，压缩的效果非常明显，特别是对于文本类的静态资源。另外，接口也是能压缩的。接口不大的话不用压缩，因为性价比低（考虑压缩和解压的时间）。

10. 利用好 script 标签的 async 和 defer 这两个属性。
    功能独立且不要求马上执行的 js 文件，可以加入 async 属性。如果是优先级低且没有依赖的 js，可以加入 defer 属性。

11. （少用）选择先进的图片格式。
    使用 WebP 的图片格式来代替现有的 jpeg 和 png，当页面图片较多时，这点作用非常明显。把部分大容量的图片从 BaseLine JPEG 切换成 Progressive JPEG（理解这两者的差别）也能缩小体积。
