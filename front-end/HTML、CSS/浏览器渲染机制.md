浏览器渲染机制
    1. 浏览器采用流式布局模型（Flow Based Layout）
    2. 浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了渲染树（Render Tree）。
    3. 有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。
    4. 由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，
        他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。
        
1.渲染过程
    1. 解析HTML，生成DOM树，解析CSS，生成CSSOM树。
    2. 将DOM树和CSSOM树结合，生成渲染树(Render Tree)。
    3. Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）。
    4. Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素。
    5. Display:将像素发送给GPU，展示在页面上。
    
2.生成渲染树
    为了构建渲染树，浏览器主要完成了以下工作：
    1. 从DOM树的根节点开始遍历每个可见节点。
    2. 对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。
    3. 根据每个可见节点以及其对应的样式，组合生成渲染树。
第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：
    1. 一些不会渲染输出的节点，比如script、meta、link等。
    2. 一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，
        还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。
###注意：渲染树只包含可见的节点

3. 回流
回流是布局或者几何属性需要改变就称为回流。
回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。
一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流.
    <div class="error">
        <h4>我的组件</h4>
        <p><strong>错误：</strong>错误的描述…</p>
        <h5>错误纠正</h5>
        <ol>
            <li>第一步</li>
            <li>第二步</li>
        </ol>
    </div>
    在上面的HTML片段中，对该段落(<p>标签)回流将会引发强烈的回流，因为它是一个子节点。这也导致了祖先的回流（div.error和body – 视浏览器而定）。
    此外，<h5>和<ol>也会有简单的回流，因为其在DOM中在回流元素之后。大部分的回流将导致页面的重新渲染。

4. 重绘
由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，
例如outline, visibility, color、background-color等，因为浏览器必须验证DOM树上其他节点元素的可见性。

5. 何时发生回流重绘
当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：
    1. 添加或删除可见的DOM元素
    2. 元素的位置发生变化
    3. 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
    4. 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
    5. 页面一开始渲染的时候（这肯定避免不了）
    6. 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

###回流必定会发生重绘，重绘不一定会引发回流。

6. 浏览器优化
现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，直到过了一段时间或者操作达到了一个阈值，
才会清空队列，但当你获取布局信息的操作的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，
浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。


主要包括以下属性或方法：
    offsetTop、offsetLeft、offsetWidth、offsetHeight
    scrollTop、scrollLeft、scrollWidth、scrollHeight
    clientTop、clientLeft、clientWidth、clientHeight
    width、height
    getComputedStyle()
    getBoundingClientRect()
以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。
因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列。
**如果要使用它们，最好将值缓存起来。

7. 减少重绘与回流
CSS
    1. 使用 transform 替代 top。
    2. 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局)。
    3. 避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。
    4. 尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。
        尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。
    5. 避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。
        <div>
            <a> <span></span> </a>
        </div>
        <style>
            span {
                color: red;
            }
            div > a > span {
                color: red;
            }
        </style>
        对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，
        但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，
        最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。
        所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平。
    6. 将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流。
    7. 避免使用CSS表达式，可能会引发回流。
    8. 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，
        例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。
    9. CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘。
        但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。
JavaScript
    1. 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
    2. 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
    3. 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
    4. 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 
